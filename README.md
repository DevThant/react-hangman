Sure, here’s a detailed overview of the Halo universe lore up to the start of Master Chief’s story:

Ancient History

The Precursors and the Forerunners

	•	Precursors: The Precursors were an ancient and advanced race believed to have created the Milky Way galaxy and its various species, including humans and Forerunners. They held the Mantle of Responsibility, a philosophy of stewardship over all life.
	•	Forerunners: The Forerunners were another ancient and highly advanced species. They revered the Precursors and inherited the Mantle of Responsibility, aiming to protect and cultivate life in the galaxy.

The Flood

	•	The Flood: A parasitic species capable of infecting and controlling other life forms. The Precursors, after being nearly exterminated by the Forerunners, transformed into the Flood as an act of vengeance.

The Forerunner-Flood War

	•	War: The Flood emerged as a major threat to the galaxy, leading to a prolonged and devastating war with the Forerunners. The Flood’s ability to infect and control sentient beings made them a nearly unstoppable force.

Halo Array

	•	Creation: In a desperate bid to stop the Flood, the Forerunners created the Halo Array, a series of massive ring-shaped superweapons. These rings were designed to wipe out all sentient life in the galaxy, starving the Flood of hosts.
	•	Activation: The Forerunners eventually activated the Halo Array, sacrificing themselves and all sentient life in the galaxy to stop the Flood. This event is known as the Great Purification.

Human Prehistory and Rise

Ancient Humanity

	•	Human-Forerunner War: Long before the Halo Array was activated, ancient humans were a space-faring species. They came into conflict with the Forerunners due to misunderstandings and the threat posed by the Flood, leading to a devastating war.
	•	Downfall: The Forerunners ultimately defeated humanity, regressing them to a primitive state and scattering them across the galaxy.

Reclamation

	•	Librarian and Didact: Two prominent Forerunners, the Librarian and the Didact, played key roles in preserving species and ensuring that humanity would eventually rise again. The Librarian seeded human worlds with genetic imprints to guide their evolution.

The Covenant

Formation

	•	Covenant: An alliance of alien species united by the worship of the Forerunners and their artifacts. The Covenant is led by the Prophets and includes species such as the Elites, Brutes, Grunts, Jackals, and others.
	•	Religious Zeal: The Covenant believes that activating Forerunner technology will lead them on a Great Journey, a path to transcendence and divinity.

Expansion and War

	•	Expansion: The Covenant rapidly expands across the galaxy, discovering and activating Forerunner artifacts. They encounter humanity, whom they view as heretics to be exterminated.
	•	Human-Covenant War: This leads to a brutal conflict known as the Human-Covenant War, with humanity struggling to survive against the technologically superior Covenant forces.

Rise of the UNSC and SPARTAN Program

United Nations Space Command (UNSC)

	•	Formation: The UNSC is the military, exploratory, and scientific agency of humanity, tasked with defending human colonies and exploring space.
	•	Colonial Conflicts: Prior to the Covenant War, humanity faced internal strife with colonies seeking independence from Earth, leading to a series of insurrections.

SPARTAN Program

	•	SPARTAN-II: In response to both the insurrectionists and the emerging Covenant threat, Dr. Catherine Halsey initiated the SPARTAN-II program. This involved kidnapping and training children to become super-soldiers through rigorous training and augmentation.
	•	SPARTAN-IIs: These soldiers, including John-117 (Master Chief), are physically and mentally enhanced to be the ultimate warriors, capable of taking on overwhelming odds.

Halo Timeline Up to Master Chief

The Covenant Attack

	•	First Contact: Humanity’s first contact with the Covenant occurs in 2525, leading to the destruction of the colony on Harvest. This marks the beginning of the Human-Covenant War.
	•	Escalation: The Covenant systematically attacks and destroys human colonies, pushing humanity to the brink of extinction.

Master Chief’s Early Years

	•	Training: John-117, known as Master Chief, emerges as one of the most capable and effective SPARTAN-IIs. His early missions establish his reputation as a skilled and resourceful soldier.
	•	Reach: The fall of Reach, a major human stronghold, is a critical moment in the war. Despite the planet’s fall, Master Chief and other survivors manage to escape, setting the stage for the events of the first Halo game.

Prelude to Halo: Combat Evolved

	•	Pillar of Autumn: As the war continues, Master Chief and the crew of the UNSC ship Pillar of Autumn discover a mysterious ring world, later known as Halo. This discovery marks the beginning of the events in “Halo: Combat Evolved,” where Master Chief’s legend truly begins.

This timeline provides a detailed look at the Halo universe leading up to the start of Master Chief’s story, highlighting key events and developments that shape the series’ rich lore.




Comparing a SPARTAN from the Halo universe to a Space Marine from the Warhammer 40k universe is an intriguing matchup, given the substantial differences in their respective settings, enhancements, and equipment. Here’s a breakdown of their capabilities and how they might fare in a one-on-one fight:

### SPARTAN-II (Master Chief or Noble Six)
- **Enhancements:** SPARTAN-IIs undergo extensive physical and mental enhancements from a young age, making them stronger, faster, and more resilient than normal humans. They have enhanced reflexes, strength, agility, and healing capabilities.
- **Armor:** They wear Mjolnir Powered Assault Armor, which provides them with augmented strength, energy shields, advanced targeting systems, and integrated AI (like Cortana for Master Chief). The armor also has environmental protection and various vision modes.
- **Weapons:** SPARTANs are proficient with a wide array of weapons, including the MA5 series assault rifles, M6 magnums, and various Covenant and Forerunner technology. They also use advanced hand-to-hand combat techniques.

### Space Marine (Warhammer 40k)
- **Enhancements:** Space Marines undergo genetic modification and extensive training to become superhuman warriors. They are implanted with various organs that enhance their strength, speed, endurance, and healing abilities. They are significantly larger and stronger than regular humans.
- **Armor:** Space Marines wear Power Armor, which includes features like enhanced strength, a life support system, and various sensors. Their armor is incredibly durable and can withstand extreme damage.
- **Weapons:** Space Marines wield powerful weapons such as Bolters, which fire explosive rounds, Chainswords for close combat, and heavy weapons like plasma guns and melta weapons. They also have a wealth of wargear and equipment designed for various combat scenarios.

### Combat Scenario Analysis

#### Physical Attributes
- **Strength and Durability:** Space Marines generally have the edge in raw physical strength and durability due to their larger size and extensive genetic modifications. Their Power Armor is also heavily fortified.
- **Agility and Reflexes:** SPARTANs might have an advantage in terms of agility and reflexes, given their training and the advanced capabilities of the Mjolnir armor.

#### Equipment and Technology
- **Weapons:** Space Marine weapons are typically more powerful and designed for high-impact damage, capable of devastating effects. However, SPARTANs have access to a wide range of advanced and versatile weaponry, including Covenant and Forerunner tech.
- **Armor:** Both have incredibly advanced armor systems. Space Marine Power Armor offers substantial protection and strength augmentation, while Mjolnir armor provides enhanced agility, shielding, and tactical advantages with AI integration.

#### Tactics and Training
- **Training:** Both SPARTANs and Space Marines are elite soldiers with rigorous training and combat experience. SPARTANs are trained from childhood to be the perfect soldiers, while Space Marines undergo intense training and indoctrination to become superhuman warriors.
- **Adaptability:** SPARTANs are known for their tactical flexibility and ability to adapt to various combat situations. Space Marines are similarly versatile but often operate with a more rigid strategic doctrine.

### Outcome
While it's difficult to definitively declare a winner given the differences in their respective universes, here are a few possible scenarios:

1. **Close Combat:** In a pure melee fight, the Space Marine's superior strength and the brutal effectiveness of weapons like the Chainsword could give them an edge over a SPARTAN. However, a SPARTAN's agility and combat training might allow them to outmaneuver and exploit weak points.

2. **Ranged Combat:** In a ranged battle, the outcome could vary depending on the specific weapons used. Space Marine Bolters are devastating, but SPARTANs could leverage their energy shields, advanced targeting systems, and possibly superior tactical planning to gain an advantage.

3. **Environmental Factors:** The environment and terrain could play a significant role. SPARTANs, with their agility and ability to quickly adapt, might perform better in varied and complex environments, while Space Marines would dominate in more straightforward, brutal confrontations.

Ultimately, the battle could go either way depending on numerous variables, but in general:
- **Space Marine:** Has the edge in raw power, durability, and heavy weaponry.
- **SPARTAN:** Has the edge in agility, reflexes, advanced technology, and tactical flexibility.

The match-up is highly situational, and either combatant could potentially claim victory under the right circumstances.


Master Chief (John-117) and Noble Six (SPARTAN-B312) are among the most prominent and capable SPARTANs in the Halo universe. Here’s an in-depth look at their strengths and the capabilities of other SPARTANs who are on a similar level.

### Master Chief (John-117)

#### Physical and Mental Enhancements
- **Strength:** Master Chief's augmentations give him superhuman strength, allowing him to lift several times his body weight. This strength is further amplified by his Mjolnir armor.
- **Speed and Agility:** He can run at speeds up to 60 km/h (37 mph) and has reaction times measured in milliseconds.
- **Resilience:** Enhanced bones make him nearly unbreakable, and his enhanced healing allows for rapid recovery from injuries.
- **Mental Acuity:** His brain functions at a highly accelerated rate, making him an exceptional tactician and combatant.

#### Armor and Equipment
- **Mjolnir Armor:** The Mark VI Mjolnir armor boosts his strength, speed, and reflexes, and provides energy shielding capable of withstanding significant damage.
- **Weapons:** Proficient with a wide range of human and Covenant weaponry, from assault rifles to energy swords.

### Noble Six (SPARTAN-B312)

#### Physical and Mental Enhancements
- **Comparable to Master Chief:** Noble Six possesses similar physical enhancements, making them extremely strong, fast, and resilient.
- **Combat Skills:** Known for exceptional combat prowess and the ability to adapt quickly to changing battle conditions. Six's abilities are on par with, if not sometimes exceeding, other SPARTAN-IIIs due to their extensive experience and skill.

#### Armor and Equipment
- **Mjolnir Armor:** Equipped with the latest versions of Mjolnir armor during the Fall of Reach, including energy shielding and advanced tactical systems.
- **Weapons:** Skilled with a variety of weapons, from conventional firearms to alien technology.

### Other Notable SPARTANs

#### SPARTAN-IIs
1. **Kelly-087**
   - **Strengths:** Known for her incredible speed and agility, often considered the fastest of the SPARTAN-IIs.
   - **Role:** Recon and close-quarters combat.

2. **Fred-104**
   - **Strengths:** Highly skilled in leadership and tactics, second only to Master Chief in combat ability.
   - **Role:** Often serves as the second-in-command in Blue Team.

3. **Linda-058**
   - **Strengths:** Exceptional marksmanship and stealth capabilities, known as the best sniper among the SPARTAN-IIs.
   - **Role:** Sniper and reconnaissance.

#### SPARTAN-IIIs
1. **Emile-A239**
   - **Strengths:** Expert in close-quarters combat, known for his ruthlessness and skill with a kukri blade.
   - **Role:** Assault and breaching operations.

2. **Jun-A266**
   - **Strengths:** Skilled sniper and scout, capable of operating independently for extended periods.
   - **Role:** Reconnaissance and long-range engagement.

3. **Carter-A259**
   - **Strengths:** Strong leadership skills and tactical planning, commanding Noble Team during the Fall of Reach.
   - **Role:** Team leader and strategist.

### Comparison and Summary

- **Physical Enhancements:** All SPARTANs undergo rigorous physical enhancements that give them superhuman abilities. SPARTAN-IIs, including Master Chief and Kelly-087, are typically stronger and more resilient due to the more intensive augmentation process.
- **Armor and Equipment:** The Mjolnir armor significantly amplifies their physical capabilities, with each new generation of armor providing better shielding, mobility, and integrated systems.
- **Skills and Experience:** SPARTAN-IIs like Master Chief, Kelly, Fred, and Linda are known for their extensive combat experience and exceptional skills. SPARTAN-IIIs like Noble Six, Emile, and Jun are also highly skilled but were often used in high-risk operations with lower survival rates.

Master Chief and Noble Six stand out due to their exceptional combat records and leadership qualities. Master Chief's legendary status is built on decades of successful missions and his role in pivotal battles against the Covenant and the Flood. Noble Six's heroism during the Fall of Reach demonstrates their combat prowess and determination.

In conclusion, while Master Chief and Noble Six are among the most formidable SPARTANs, they are part of a larger cadre of elite soldiers, each with unique strengths that contribute to their effectiveness in various combat scenarios.

During the Human-Covenant War, the number of SPARTANs varied across different generations, and newer generations of SPARTANs and advanced armor systems have been developed over time. Here’s a detailed breakdown:

### SPARTAN Generations

#### SPARTAN-I Program
- **Overview:** The initial SPARTAN-I program, also known as the ORION Project, was an early attempt to create super-soldiers. The program had limited success and produced a small number of augmented soldiers.
- **Numbers:** Approximately 300 candidates, with fewer than 50 successful augmentations.

#### SPARTAN-II Program
- **Overview:** The SPARTAN-II program, initiated by Dr. Halsey, was more successful and created highly effective super-soldiers through extensive genetic and cybernetic augmentations.
- **Numbers:** Initially, 75 children were abducted and trained, but not all survived the augmentation process. Approximately 33 SPARTAN-IIs were fully operational at the start of the Covenant War. Over time, some were lost in battle, reducing their numbers further.

#### SPARTAN-III Program
- **Overview:** The SPARTAN-III program was designed to produce more SPARTANs at a lower cost, using less intensive augmentations. These soldiers were often deployed in high-risk missions with high casualty rates.
- **Numbers:** Three main companies were created:
  - **Alpha Company:** Approximately 300 SPARTAN-IIIs.
  - **Beta Company:** Approximately 300 SPARTAN-IIIs.
  - **Gamma Company:** Approximately 330 SPARTAN-IIIs.
  - Not all SPARTAN-IIIs survived their missions, and many were considered expendable.

#### SPARTAN-IV Program
- **Overview:** The SPARTAN-IV program, initiated post-war, recruited adult volunteers from existing military personnel and provided them with advanced augmentations and armor.
- **Numbers:** The exact number is classified, but there are several hundred SPARTAN-IVs. This program aims to produce a larger number of SPARTANs with less intensive but still significant enhancements.

### Latest Armors and Weapons

#### Armor Systems

1. **Mjolnir GEN2 Armor**
   - **Features:** Enhanced strength, speed, and agility. Integrated AI support, energy shielding, and modular components for customization.
   - **Variants:** Multiple variants exist for different combat roles, such as the Recon, Scout, and Defender sets.

2. **Mjolnir GEN3 Armor**
   - **Features:** Further enhancements over GEN2, with improved energy shielding, better mobility, and advanced sensors.
   - **Deployment:** Used primarily by SPARTAN-IVs and later generations.

3. **SPI Armor (Semi-Powered Infiltration)**
   - **Features:** Designed for SPARTAN-IIIs, providing stealth capabilities and lighter protection compared to Mjolnir armor. Enhanced mobility and integrated camouflage systems.

#### Weapons

1. **MA5 Series Assault Rifles**
   - **Overview:** Standard-issue weapons for SPARTANs, reliable and versatile.
   - **Variants:** Includes the MA5B and MA5C, with different specifications for range, accuracy, and fire rate.

2. **M6 Series Pistols**
   - **Overview:** Powerful handguns with high accuracy and stopping power.
   - **Variants:** M6D and M6G are commonly used by SPARTANs.

3. **BR55 Battle Rifle**
   - **Overview:** A burst-fire weapon favored for its precision and effectiveness at medium range.
   - **Features:** Equipped with a scope for improved accuracy.

4. **SRS99 Sniper Rifle**
   - **Overview:** A high-powered, long-range weapon used for precision targeting.
   - **Features:** Equipped with a high-magnification scope and armor-piercing rounds.

5. **M7 SMG**
   - **Overview:** A compact, fully automatic weapon suitable for close-quarters combat.
   - **Features:** High rate of fire and ease of use in tight spaces.

6. **Spartan Laser (M6 G/GNR)**
   - **Overview:** A directed-energy weapon capable of destroying vehicles and heavily armored targets.
   - **Features:** High damage output but requires charging before firing.

7. **Energy Sword**
   - **Overview:** A Covenant melee weapon highly effective in close combat.
   - **Features:** Plasma blade capable of cutting through most materials.

8. **Gravity Hammer**
   - **Overview:** A melee weapon used by the Brutes, capable of generating shockwaves.
   - **Features:** Extremely powerful and can knock back or destroy multiple enemies at once.

### Summary

During the Human-Covenant War, humanity had several generations of SPARTANs, with the SPARTAN-II and SPARTAN-III programs producing the most notable super-soldiers. Post-war, the SPARTAN-IV program expanded the number of SPARTANs significantly.

The latest armor systems, such as the Mjolnir GEN2 and GEN3, provide advanced protection, mobility, and support for the SPARTANs, while a variety of powerful weapons ensure they are well-equipped for any combat scenario.

A team battle between SPARTANs from the Halo universe and Space Marines from the Warhammer 40k universe would be a clash of two elite warrior groups, each with their own unique strengths, technology, and combat strategies. Here’s a detailed comparison to analyze who might emerge victorious in such a confrontation:

### SPARTANs (Halo)

#### Strengths
1. **Training and Tactics:** SPARTANs are highly trained from a young age and are exceptional in both individual combat skills and team-based tactics. They are trained to be adaptable, resourceful, and highly coordinated in combat scenarios.
2. **Augmentations:** SPARTANs undergo rigorous physical and mental augmentations, making them superhumanly strong, fast, and resilient.
3. **Armor Technology:** Mjolnir Powered Assault Armor provides energy shields, enhanced strength and agility, advanced targeting systems, and environmental protection.
4. **Integrated AI:** Some SPARTANs, like Master Chief, have integrated AI (such as Cortana) that provide real-time tactical analysis, hacking capabilities, and battlefield intelligence.
5. **Versatile Weaponry:** SPARTANs have access to a wide range of human and Covenant weaponry, allowing them to adapt to various combat situations.

#### Notable SPARTAN Teams
- **Blue Team:** Led by Master Chief, known for exceptional coordination and effectiveness.
- **Noble Team:** Known for their heroism during the Fall of Reach, demonstrating remarkable combat skills and teamwork.

### Space Marines (Warhammer 40k)

#### Strengths
1. **Genetic Enhancements:** Space Marines undergo extensive genetic modification, giving them superhuman strength, endurance, and resilience. They are significantly larger and more physically imposing than SPARTANs.
2. **Power Armor:** Space Marine Power Armor is heavily fortified, provides enhanced strength, and is equipped with life support systems, advanced sensors, and various wargear options.
3. **Devastating Weaponry:** Space Marines wield powerful weapons like Bolters (which fire explosive rounds), Chainswords, Plasma Guns, and heavy weapons such as Lascannons and Melta Guns.
4. **Psychic Abilities:** Some Space Marines, known as Librarians, have psychic powers that can be used for offense, defense, and battlefield manipulation.
5. **Combat Experience:** Space Marines have centuries or even millennia of combat experience, and their doctrines are based on both ancient wisdom and relentless training.

#### Notable Space Marine Chapters
- **Ultramarines:** Known for their adherence to the Codex Astartes and tactical prowess.
- **Blood Angels:** Renowned for their ferocity in combat and their unique abilities.
- **Space Wolves:** Known for their savagery and exceptional close combat skills.

### Scenario Analysis

#### Physical Attributes and Armor
- **Strength and Durability:** Space Marines generally have the edge in raw physical strength and durability due to their extensive genetic modifications and heavily fortified Power Armor.
- **Agility and Reflexes:** SPARTANs might have an advantage in terms of agility and reflexes, thanks to their augmentations and the advanced capabilities of the Mjolnir armor.

#### Equipment and Technology
- **Weapons:** Space Marine weapons are typically more powerful and designed for high-impact damage, capable of devastating effects. However, SPARTANs have versatile weaponry, including energy shields and advanced targeting systems.
- **Armor:** Both have incredibly advanced armor systems. Space Marine Power Armor offers substantial protection and strength augmentation, while Mjolnir armor provides enhanced agility, shielding, and tactical advantages with AI integration.

#### Tactics and Teamwork
- **Training and Coordination:** Both SPARTANs and Space Marines are elite soldiers with rigorous training. SPARTANs are known for their tactical flexibility and ability to adapt to various combat situations. Space Marines have a more rigid strategic doctrine but are relentless and highly disciplined in their approach.
- **Psychic Abilities:** Space Marines’ Librarians can turn the tide with their psychic powers, providing an unpredictable and potent advantage.

### Possible Outcomes

1. **Open Battlefield:** In a straightforward, open-field battle, Space Marines might have an edge due to their sheer physical power, durability, and devastating weaponry. Their experience and psychic abilities could also play a significant role.
2. **Urban or Complex Terrain:** In environments requiring agility and adaptability, SPARTANs could leverage their superior reflexes, advanced tactical systems, and integrated AI to outmaneuver and outthink Space Marines.
3. **Team Coordination:** Both sides excel in teamwork, but SPARTANs’ adaptability and real-time AI support might give them a slight advantage in dynamic and rapidly changing scenarios.

### Summary
- **Space Marines:** Hold the edge in raw power, durability, heavy weaponry, and psychic abilities. Their combat experience and relentless tactics make them formidable opponents.
- **SPARTANs:** Excel in agility, reflexes, advanced technology, and tactical flexibility. Their integrated AI and versatile weaponry allow them to adapt to various combat situations effectively.

The outcome of such a battle would likely depend heavily on the specific circumstances and terrain. In many scenarios, Space Marines' sheer power and durability could give them the upper hand, while in more dynamic and complex environments, SPARTANs' adaptability and advanced technology could turn the tide in their favor.








Got it. Let's create a plan to integrate the synchronization progress into the toaster component. Here's the detailed step-by-step plan for implementing this feature:

1. **Add progress and totalModels Props to `SpinnerToast.vue`:**
    - Modify the `SpinnerToast.vue` component to accept `progress` and `totalModels` props.
    - Update the template to display the synchronization progress.

2. **Modify `Toaster.vue` to Pass Progress Data:**
    - Ensure the `Toaster.vue` component can pass the `progress` and `totalModels` props to `SpinnerToast`.

3. **Update `toastService` to Handle Synchronization Progress:**
    - Modify the `toastService` to include `progress` and `totalModels` in the toast properties when creating spinner toasts.

4. **Modify `Sync.vue` to Emit Progress Updates:**
    - Update the `Sync.vue` component to emit progress updates via the `toastService`.

### Step 1: Update `SpinnerToast.vue`

```vue
<template>
  <div class="item default">
    <div class="header">
      <span class="title semi-bold">{{ titleText }}</span>
      <app-icon-button
        v-if="dismissable"
        :title="t('common.dismiss')"
        :name="'times'"
        class="icon-button dismiss"
        @click="dismiss"
      />
    </div>
    <app-horizontal-spinner class="spinner" :thin="true"></app-horizontal-spinner>
    <div class="progress">
      {{ progress }} / {{ totalModels }} models are done. <!-- Added progress display -->
    </div>
  </div>
</template>

<script setup lang="ts">
import { onBeforeUnmount, onMounted } from 'vue';

import AppIconButton from '@/components/common/icon/IconButton.vue';
import AppHorizontalSpinner from '@/components/common/spinner/HorizontalSpinner.vue';

import { ToastEvent, toastService } from '@/services/toast.js';
import { useI18n } from 'vue-i18n';

defineOptions({ name: 'SpinnerToast' });

const props = withDefaults(
  defineProps<{
    id: symbol;
    title: string;
    titleVars?: Record<string, unknown>;
    dismissable?: boolean;
    progress: number;      // Added new prop for progress
    totalModels: number;   // Added new prop for total models
  }>(),
  {
    titleVars: () => ({}),
    dismissable: false,
    progress: 0,          // Default value for progress
    totalModels: 0        // Default value for total models
  }
);

const emit = defineEmits<{ dismiss: [id: symbol] }>();

const { t, te } = useI18n();

const dismiss = () => emit('dismiss', props.id);

const onDismiss = (id: symbol) => {
  if (id === props.id) {
    dismiss();
  }
};

const titleText: string = te(props.title) ? t(props.title, props.titleVars) : props.title;
onMounted(() => {
  toastService.on(ToastEvent.Dismiss, onDismiss);
});

onBeforeUnmount(() => {
  toastService.off(ToastEvent.Dismiss, onDismiss);
});
</script>

<style scoped>
.icon-button {
  background-color: transparent;
  border-width: 0;
  padding: 0;
  height: 16px;
  width: 16px;
  cursor: pointer;
}

.header {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  width: 100%;
}

.header .title {
  flex-grow: 1;
  padding-right: var(--base-spacing-0);
}

.header .dismiss {
  fill: var(--toaster-dismiss-icon);
  flex-shrink: 0;
  height: 16px;
  width: 16px;
  font-size: 16px;
  display: inline-block;
}

.header .dismiss:hover {
  fill: var(--toaster-dismiss-icon);
}

.spinner {
  margin: 15px 0 15px;
}

.progress {
  font-size: 14px;
  color: var(--toaster-progress-text-color); // Style for progress text
  margin-top: 10px;
}
</style>
```

### Step 2: Modify `Toaster.vue`

```vue
<template>
  <transition-group
    v-if="displayedToasts.length"
    name="list"
    tag="div"
    class="container lead"
    data-testid="toaster"
  >
    <component
      :is="toast.component"
      v-for="toast in displayedToasts"
      :key="toast.id"
      v-bind="{ id: toast.id, class: 'toast', ...toast.properties, progress: toast.properties.progress, totalModels: toast.properties.totalModels }" <!-- Added progress and totalModels binding -->
      @click="toast.properties.onClick"
      @dismiss="removeToast"
    />
  </transition-group>
</template>

<script setup lang="ts">
import { onBeforeUnmount, onMounted, ref, shallowRef } from 'vue';

import { toastService, ToastEvent, Toast } from '@/services/toast.js';

defineOptions({ name: 'Toaster' });

const displayedToasts = shallowRef<Toast[]>([]);
const toastTimeouts = ref<Map<symbol, number>>(new Map());

const removeToast = (id: symbol): void => {
  if (toastTimeouts.value.has(id)) {
    window.clearTimeout(toastTimeouts.value.get(id));
    toastTimeouts.value.delete(id);
  }

  displayedToasts.value = displayedToasts.value.filter(toast => toast.id !== id);
};

const displayToast = (toast: Toast): void => {
  displayedToasts.value = [...displayedToasts.value, toast];

  if (toast.timeout) {
    const timeoutHandle = window.setTimeout(() => {
      removeToast(toast.id);
    }, toast.timeout);

    toastTimeouts.value.set(toast.id, timeoutHandle);
  }
};

const clearAllToasts = () => {
  displayedToasts.value = [];
};

onMounted(() => {
  toastService.on(ToastEvent.Display, displayToast);
  toastService.on(ToastEvent.CloseAll, clearAllToasts);
});

onBeforeUnmount(() => {
  toastService.off(ToastEvent.Display, displayToast);
  toastService.off(ToastEvent.CloseAll, clearAllToasts);
});
</script>

<style scoped>
.container {
  position: absolute;
  width: 100%;
  min-height: 24px;
  display: flex;
  flex-direction: column;
  align-content: flex-end;
  z-index: 101;
  background: transparent;
  font-family: var(--font-family);
}

.container > * {
  position: relative;
  width: 100%;
  display: block;
  padding: var(--base-spacing-7);
  margin: var(--base-spacing-0);
  border-radius: var(--base-radius);
  overflow: hidden;
  z-index: 3;
  color: var(--white);
  background: var(--toaster-background-color-default);
}

.container > *.default {
  background: var(--toaster-background-color-default);
  border: 2px solid var(--toaster-border-color-default);
}

.container > *.info {
  background: var(--toaster-background-color-info);
  border: 0;
}

.container > *.warning {
  background: var(--toaster-background-color-default);
  border: 2px solid var(--toaster-border-color-warning);
}

.container > *.error {
  background: var(--toaster-background-color-default);
  border: 2px solid var(--toaster-border-color-error);
}

.list-enter-active {
  transition: all 0.8s linear;
}

.list-leave-active {
  transition: all 0.4s linear;
}

.list-enter {
  opacity: 0;
}

.list-leave-to {
  opacity: 0;
}
</style>
```

### Step 3: Update `toastService.ts`

```ts
import { DefineComponent } from 'vue';
import mitt, { Emitter, Handler } from 'mitt';
import { LoggingService } from '@ebitoolmx/logging-service/console';
import { loggingService as commonLoggingService } from './logging.js';

export enum ToastEvent {
  Display = 'display',
  Dismiss = 'dismiss',
  CloseAll = 'closeAll'
}

export enum ToastType {
  Simple = 'simple',
  UpdateAvailable = 'updateAvailable',
  Spinner = 'spinner',
  Reconnecting = 'reconnecting',
  PickUpWhereYouLeftOff = 'pickUpWhereYouLeftOff'
}

/**
 * All the required details for displaying a toast in the Toaster component.
 */
export interface Toast {
  id: symbol;
  component?: DefineComponent;
  properties: Record<string, unknown>;
  timeout?: number;
}

type Events = {
  [ToastEvent.Display]: Toast;
  [ToastEvent.Dismiss]: symbol;
  [ToastEvent.CloseAll]: undefined;
};

/**
 * Handles toaster events and components for the toaster component.
 */
export class ToastService {
  protected toastComponents = new Map<ToastType | string, DefineComponent>();

  protected events: Emitter<Events> = mitt<Events>();

  public constructor(protected loggingService: LoggingService) {}

  /**
   * Registers a toast into the service so that it can be referenced later when displaying
   */
  public registerToast(type: ToastType | string, toast: any) {
    this.toastComponents.set(type, toast);
  }

  /**
   * Displays a toast with a given id and of specified type. This will emit an event to the Toaster
   * component with the necessary details to display a toast. This is the most low-level endpoint
  

 * that all details to be able to display a toast.
   */
  public displayWithId(
    id: symbol,
    type: ToastType | string,
    props: Record<string, unknown> = {},
    timeout: number | undefined = undefined
  ): symbol {
    const properties = props;
    const component = this.toastComponents.get(type);

    if (!component) this.loggingService.error(`Toast type '${type}' has not been registered.`);

    this.events.emit(ToastEvent.Display, { id, component, properties, timeout });
    this.loggingService.debug(`Displaying toast of type '${type}'`);

    return id;
  }

  /**
   * Displays a toast of a specified type. This will auto generate an id and return it before
   * emitting an event to the Toaster component. See displayWithId().
   */
  public display(
    type: ToastType | string,
    props: Record<string, unknown> = {},
    timeout: number | undefined = undefined
  ): symbol {
    return this.displayWithId(Symbol('toast'), type, props, timeout);
  }

  /**
   * Displays a simple info toast with a provided message and optional timeout
   */
  public displayInfo(message: string, timeout?: number): symbol;

  /**
   * Displays a simple info toast with a provided header, message, and optional timeout
   */
  public displayInfo(header: string, message: string, timeout?: number): symbol;

  /**
   * A fallback implementation for displayInfo that will determine which argument is the toast
   * message, header, and timeout based on the argument types.
   */
  public displayInfo(arg1: string, arg2?: string | number, arg3?: number): symbol {
    const header: string | undefined = typeof arg2 === 'string' ? arg1 : undefined;
    const message: string | undefined = typeof arg2 === 'string' ? arg2 : arg1;
    const timeout: number | undefined = typeof arg2 === 'number' ? arg2 : arg3;

    return this.display(ToastType.Simple, { title: header, text: message, type: 'info' }, timeout);
  }

  /**
   * Displays a simple warning toast with a provided message and optional timeout
   */
  public displayWarning(message: string, timeout?: number): symbol;

  /**
   * Displays a simple warning toast with a provided header, message, and optional timeout
   */
  public displayWarning(header: string, message: string, timeout?: number): symbol;

  /**
   * A fallback implementation for displayWarning that will determine which argument is the toast
   * message, header, and timeout based on the argument types.
   */
  public displayWarning(arg1: string, arg2?: string | number, arg3?: number): symbol {
    const header: string | undefined = typeof arg2 === 'string' ? arg1 : undefined;
    const message: string | undefined = typeof arg2 === 'string' ? arg2 : arg1;
    const timeout: number | undefined = typeof arg2 === 'number' ? arg2 : arg3;

    return this.display(
      ToastType.Simple,
      { title: header, text: message, type: 'warning' },
      timeout
    );
  }

  /**
   * Displays a simple error toast with a provided message
   */
  public displayError(message: string): symbol;

  /**
   * Displays a simple error toast with a provided message and header
   */
  public displayError(header: string, message: string): symbol;

  /**
   * A fallback implementation for typing.
   */
  public displayError(arg1: string, arg2?: string): symbol {
    const header = arg2 ? arg1 : undefined;
    const message = arg2 ?? arg1;

    return this.display(ToastType.Simple, { title: header, text: message, type: 'error' });
  }

  /**
   * Will display a spinner toaster with the provided id and header.
   */
  public displaySpinner(id: symbol, header: string, progress: number, totalModels: number): symbol { // Updated method to accept progress and totalModels
    return this.displayWithId(id, ToastType.Spinner, { title: header, progress, totalModels }); // Pass progress and totalModels to props
  }

  /**
   * Dismisses a toast with the provided id if it is still present on the screen.
   */
  public dismiss(id: symbol): void {
    this.events.emit(ToastEvent.Dismiss, id);
  }

  /**
   * Closes all toasts
   */
  public closeAll(): void {
    this.events.emit(ToastEvent.CloseAll);
  }

  /**
   * Subscribe to the closeAll toast event in the toast service
   */
  public on<Type extends ToastEvent.CloseAll>(type: Type, callback: Function): void;

  /**
   * Subscribe to the dismiss toast event in the toast service
   */
  public on<Type extends ToastEvent.Dismiss>(type: Type, callback: Function): void;

  /**
   * Subscribe to the display toast event. This event will pass information about the toast to be
   * displayed.
   */
  public on<Type extends ToastEvent.Display>(type: Type, callback: (toast: Toast) => void): void;

  /**
   * A fallback type for subscribing to events in the toast service.
   */
  public on<T extends ToastEvent>(type: T, callback: Handler<Events[T]>): void {
    this.events.on(type, callback);
  }

  /**
   * Unsubscribe from from an event in the toast service
   */
  public off<T extends ToastEvent>(type: T, callback: Handler<Events[T]>): void {
    this.events.off(type, callback);
  }
}

export const toastService = new ToastService(commonLoggingService);
```

### Step 4: Modify `Sync.vue`

Ensure the `Sync.vue` component can update the toast with progress information.

```vue
<template>
  <app-dialog-container title-key="sync.modal.title" data-testid="dialog-sync">
    <template #content>
      <app-dialog-process-content-layout
        v-if="isSyncProcessingDialog"
        :header="t(header)"
        :description-line1="message ? t(message) : message"
      >
        <template #extra-content>
          <ul class="sync-progress lead dialog-content-message">
            <li
              v-for="(model, index) of status?.allModels"
              :key="index"
              :class="{
                syncing: status?.currentModelName === model,
                synced: status?.syncedModels.includes(model)
              }"
            >
              <app-icon :name="progressIcon(model)" />
              {{ model }}
            </li>
          </ul>
        </template>
      </app-dialog-process-content-layout>

      <app-dialog-icon-content-layout
        v-else
        :icon="icon"
        :icon-color="iconColor"
        :header="t(header)"
      >
        <template #extra-content>
          <div v-if="isSyncUnsuccessfulDialog || isSyncFailedDialog" class="unsuccessful">
            <div class="unsuccessful-message">
              <p v-if="isSyncUnsuccessfulDialog" class="lead dialog-content-message">
                {{ t('sync.modal.message.unsuccessful') }}
              </p>
              <p class="lead dialog-content-message">{{ t('sync.modal.message.contact') }}</p>
              <a
                :href="t('common.link')"
                rel="noopener noreferrer"
                target="_blank"
                class="lead dialog-content-message"
              >
                {{ t('common.helpSupport') }}
              </a>
              <p class="lead dialog-content-message">.</p>
            </div>

            <div v-if="status?.currentModelName && isSyncUnsuccessfulDialog" class="failed-model">
              <app-icon name="sync_error" />
              <p class="lead dialog-content-message">{{ status.currentModelName }}</p>
            </div>
          </div>
          <div v-else-if="isSyncSuccessfulDialog" class="successful">
            <ul class="sync-progress lead dialog-content-message">
              <li v-for="(model, index) of status?.syncedModels" :key="index" class="synced">
                <app-icon name="sync_success" />
                {{ model }}
              </li>
            </ul>
          </div>
        </template>
      </app-dialog-icon-content-layout>
    </template>

    <template #button-row>
      <app-button
        data-testid="reject-sync"
        :disabled="appStore.hasBlockingTasks"
        :class="{ primary: !isSyncRequestDialog, secondary: isSyncRequestDialog }"
        @click="emit('close')"
        >{{ t('common.close') }}</app-button
      >
      <app-button
        v-if="isSyncRequestDialog"
        data-testid="accept-sync"
        class="primary"
        :disabled="startDisabled"
        @click="start"
        >{{ t('common.start') }}</app-button
      >
    </template>
  </app-dialog-container>
</template>
<script setup lang="ts">
import { watch, computed } from 'vue';
import { PickupPaths, useI18n } from 'vue-i18n';

import { exhaustiveTypeCheck } from '@ebitoolmx/predicates';

import AppIcon from '@/components/common/icon/Icon.vue';
import AppButton from '@/components/common/formElements/button/Button.vue';
import AppDialogContainer from '@/components/common/dialog/layouts/DialogContainer.vue';
import AppDialogIconContentLayout, {
  IconColor
} from '@/components/common/dialog/layouts/DialogIconContentLayout.vue';
import AppDialogProcessContentLayout from '@/components/common/dialog/layouts/DialogProcessContentLayout.vue';



import { SyncDialogType } from '@/typings/sync.js';
import { DialogNames } from '@/typings/dialog.js';

import { useAppStore } from '@/stores/app.js';
import { useProductsStore } from '@/stores/products.js';
import { useConnectionsStore } from '@/stores/connections.js';
import { useEditorStore } from '@/stores/editor.js';

import { eventService, EventType } from '@/services/event.js';

import { LocaleMessage } from '@/locale/en.js';
import { MXSyncProgressEvent, MXSyncProgressStatus } from '@ebitoolmx/gateway-types';
import { useAuthService } from '@/auth/index.js';

import { toastService } from '@/services/toast.js'; // Import toastService

defineOptions({ name: 'Sync' });
const props = defineProps<{
  dialogType: SyncDialogType;
  status?: MXSyncProgressEvent;
}>();

const emit = defineEmits(['close']);
const appStore = useAppStore();
const { userDetails } = useAuthService();
const connectionsStore = useConnectionsStore();
const productsStore = useProductsStore();
const editorStore = useEditorStore();
const { t } = useI18n();

const header = computed<PickupPaths<LocaleMessage>>(() => {
  switch (props.dialogType) {
    case SyncDialogType.Requested:
      return 'sync.modal.header.requested';
    case SyncDialogType.Initialising:
      return 'sync.modal.header.initialising';
    case SyncDialogType.Processing:
      return 'sync.modal.header.processing';
    case SyncDialogType.Successful:
      return 'sync.modal.header.successful';
    case SyncDialogType.InitialisingFailed:
      return 'sync.modal.header.initialisingFailed';
    case SyncDialogType.Unsuccessful:
      return 'sync.modal.header.unsuccessful';
    case SyncDialogType.Offline:
      return 'sync.modal.header.offline';
    default:
      return exhaustiveTypeCheck(props.dialogType);
  }
});

const message = computed<PickupPaths<LocaleMessage> | null>(() => {
  switch (props.dialogType) {
    case SyncDialogType.Requested:
      return 'sync.modal.message.requested';
    case SyncDialogType.Processing:
      return 'sync.modal.message.progress';
    case SyncDialogType.Offline:
      return 'sync.modal.message.offline';
    case SyncDialogType.Initialising:
      return null;
    case SyncDialogType.Successful:
      return null;
    case SyncDialogType.InitialisingFailed:
      return null;
    case SyncDialogType.Unsuccessful:
      return null;
    default:
      return exhaustiveTypeCheck(props.dialogType);
  }
});

const progressIcon = (model: string) => {
  if (props.status?.syncedModels.includes(model)) {
    return 'sync_success';
  }
  if (props.status?.currentModelName === model) {
    return 'sync_in_progress';
  }
  return 'sync_no_progress';
};

const icon = computed<string>(() => {
  switch (props.dialogType) {
    case SyncDialogType.Requested:
      return 'sync';
    case SyncDialogType.Successful:
      return 'sync_success';
    case SyncDialogType.Unsuccessful:
      return 'warning';
    case SyncDialogType.InitialisingFailed:
      return 'warning';
    case SyncDialogType.Offline:
      return 'cloud-offline';
    default:
      return '';
  }
});

const iconColor = computed<IconColor>(() => {
  switch (props.dialogType) {
    case SyncDialogType.Requested:
      return 'text';
    case SyncDialogType.Successful:
      return 'success';
    case SyncDialogType.Unsuccessful:
      return 'danger';
    case SyncDialogType.InitialisingFailed:
      return 'danger';
    case SyncDialogType.Offline:
      return 'warning';
    default:
      return 'text';
  }
});

const isSyncRequestDialog = computed<boolean>(() => props.dialogType === SyncDialogType.Requested);

const isSyncProcessingDialog = computed<boolean>(
  () =>
    props.dialogType === SyncDialogType.Processing ||
    props.dialogType === SyncDialogType.Initialising
);

const isSyncSuccessfulDialog = computed<boolean>(
  () => props.dialogType === SyncDialogType.Successful
);

const isSyncUnsuccessfulDialog = computed<boolean>(
  () => props.dialogType === SyncDialogType.Unsuccessful
);

const isSyncFailedDialog = computed<boolean>(
  () => props.dialogType === SyncDialogType.InitialisingFailed
);

const startDisabled = computed<boolean>(
  () =>
    appStore.hasBlockingTasks ||
    props.status?.syncProgressStatus === MXSyncProgressStatus.Synchronizing
);

function start() {
  const email = userDetails.value?.email;
  if (!email) return;

  productsStore.syncProduct({
    productId: productsStore.activeProductId,
    userId: email,
    editorType: editorStore.editorType
  });

  // Emit progress update to the toastService
  const toastId = Symbol('sync-toast');
  const totalModels = props.status?.allModels.length || 0;
  toastService.displaySpinner(toastId, 'Synchronization requested', 0, totalModels);

  const interval = setInterval(() => {
    const progress = props.status?.syncedModels.length || 0;
    toastService.displaySpinner(toastId, 'Synchronization requested', progress, totalModels);
    
    if (progress >= totalModels) {
      clearInterval(interval);
      toastService.dismiss(toastId);
    }
  }, 1000);
}

watch(
  () => connectionsStore.isOffline,
  nowOffline => {
    if (nowOffline)
      eventService.emit(EventType.OpenDialog, {
        dialogName: DialogNames.Sync,
        options: {
          props: {
            dialogType: SyncDialogType.Offline
          },
          modal: true
        }
      });
  }
);
</script>

<style scoped>
.sync-progress {
  color: var(--font-disabled-color);
  fill: var(--font-disabled-color);

  li {
    display: flex;
    align-items: center;

    .icon {
      margin-right: var(--base-spacing-1);
    }
  }

  .syncing {
    color: var(--font-color);
    fill: var(--font-color);
  }

  .synced {
    color: var(--success);
    fill: var (--success);
  }
}

.unsuccessful {
  display: flex;
  flex-direction: column;
  align-items: center;

  .unsuccessful-message {
    display: flex;

    a {
      color: var(--link-color);
    }

    p {
      padding-right: var(--base-spacing-1);
    }
  }

  .failed-model {
    display: flex;
    align-items: center;
    color: var(--danger);
    fill: var(--danger);

    p {
      padding-left: var(--base-spacing-1);
    }
  }
}

.successful {
  display: flex;
  flex-direction: column;
  align-items: center;

  ul {
    list-style: none;
    padding: 0;
    margin: 0;

    li {
      display: flex;
      align-items: center;
      margin-bottom: var(--base-spacing-1);

      .icon {
        margin-right: var(--base-spacing-1);
      }
    }
  }
}
</style>
```

### Summary of Changes with Comments

1. **`SpinnerToast.vue`:** Added `progress` and `totalModels` props and updated the template to display synchronization progress.
2. **`Toaster.vue`:** Modified the `v-bind` to pass `progress` and `totalModels` to the `SpinnerToast` component.
3. **`toastService.ts`:** Updated the `displaySpinner` method to accept `progress` and `totalModels` and pass them as properties.
4. **`Sync.vue`:** Added logic to emit progress updates to the `toastService`.

By following this plan, you'll be able to display synchronization progress in the toaster component, reflecting the real-time synchronization status to other users in the same workspace. If you encounter any issues or need further assistance, let me know!



-message">.</p>
            </div>

            <div v-if="status?.currentModelName && isSyncUnsuccessfulDialog" class="failed-model">
              <app-icon name="sync_error" />
              <p class="lead dialog-content-message">{{ status.currentModelName }}</p>
            </div>
          </div>
          <div v-else-if="isSyncSuccessfulDialog" class="successful">
            <ul class="sync-progress lead dialog-content-message">
              <li v-for="(model, index) of status?.syncedModels" :key="index" class="synced">
                <app-icon name="sync_success" />
                {{ model }}
              </li>
            </ul>
          </div>
        </template>
      </app-dialog-icon-content-layout>
    </template>

    <template #button-row>
      <app-button
        data-testid="reject-sync"
        :disabled="appStore.hasBlockingTasks"
        :class="{ primary: !isSyncRequestDialog, secondary: isSyncRequestDialog }"
        @click="emit('close')"
        >{{ t('common.close') }}</app-button
      >
      <app-button
        v-if="isSyncRequestDialog"
        data-testid="accept-sync"
        class="primary"
        :disabled="startDisabled"
        @click="start"
        >{{ t('common.start') }}</app-button
      >
    </template>
  </app-dialog-container>
</template>
<script setup lang="ts">
import { watch, computed } from 'vue';
import { PickupPaths, useI18n } from 'vue-i18n';

import { exhaustiveTypeCheck } from '@ebitoolmx/predicates';

import AppIcon from '@/components/common/icon/Icon.vue';
import AppButton from '@/components/common/formElements/button/Button.vue';
import AppDialogContainer from '@/components/common/dialog/layouts/DialogContainer.vue';
import AppDialogIconContentLayout, {
  IconColor
} from '@/components/common/dialog/layouts/DialogIconContentLayout.vue';
import AppDialogProcessContentLayout from '@/components/common/dialog/layouts/DialogProcessContentLayout.vue';

import { SyncDialogType } from '@/typings/sync.js';
import { DialogNames } from '@/typings/dialog.js';

import { useAppStore } from '@/stores/app.js';
import { useProductsStore } from '@/stores/products.js';
import { useConnectionsStore } from '@/stores/connections.js';
import { useEditorStore } from '@/stores/editor.js';

import { eventService, EventType } from '@/services/event.js';

import { LocaleMessage } from '@/locale/en.js';
import { MXSyncProgressEvent, MXSyncProgressStatus } from '@ebitoolmx/gateway-types';
import { useAuthService } from '@/auth/index.js';

import { toastService } from '@/services/toast.js'; // Import toastService

defineOptions({ name: 'Sync' });
const props = defineProps<{
  dialogType: SyncDialogType;
  status?: MXSyncProgressEvent;
}>();

const emit = defineEmits(['close']);
const appStore = useAppStore();
const { userDetails } = useAuthService();
const connectionsStore = useConnectionsStore();
const productsStore = useProductsStore();
const editorStore = useEditorStore();
const { t } = useI18n();

const header = computed<PickupPaths<LocaleMessage>>(() => {
  switch (props.dialogType) {
    case SyncDialogType.Requested:
      return 'sync.modal.header.requested';
    case SyncDialogType.Initialising:
      return 'sync.modal.header.initialising';
    case SyncDialogType.Processing:
      return 'sync.modal.header.processing';
    case SyncDialogType.Successful:
      return 'sync.modal.header.successful';
    case SyncDialogType.InitialisingFailed:
      return 'sync.modal.header.initialisingFailed';
    case SyncDialogType.Unsuccessful:
      return 'sync.modal.header.unsuccessful';
    case SyncDialogType.Offline:
      return 'sync.modal.header.offline';
    default:
      return exhaustiveTypeCheck(props.dialogType);
  }
});

const message = computed<PickupPaths<LocaleMessage> | null>(() => {
  switch (props.dialogType) {
    case SyncDialogType.Requested:
      return 'sync.modal.message.requested';
    case SyncDialogType.Processing:
      return 'sync.modal.message.progress';
    case SyncDialogType.Offline:
      return 'sync.modal.message.offline';
    case SyncDialogType.Initialising:
      return null;
    case SyncDialogType.Successful:
      return null;
    case SyncDialogType.InitialisingFailed:
      return null;
    case SyncDialogType.Unsuccessful:
      return null;
    default:
      return exhaustiveTypeCheck(props.dialogType);
  }
});

const progressIcon = (model: string) => {
  if (props.status?.syncedModels.includes(model)) {
    return 'sync_success';
  }
  if (props.status?.currentModelName === model) {
    return 'sync_in_progress';
  }
  return 'sync_no_progress';
};

const icon = computed<string>(() => {
  switch (props.dialogType) {
    case SyncDialogType.Requested:
      return 'sync';
    case SyncDialogType.Successful:
      return 'sync_success';
    case SyncDialogType.Unsuccessful:
      return 'warning';
    case SyncDialogType.InitialisingFailed:
      return 'warning';
    case SyncDialogType.Offline:
      return 'cloud-offline';
    default:
      return '';
  }
});

const iconColor = computed<IconColor>(() => {
  switch (props.dialogType) {
    case SyncDialogType.Requested:
      return 'text';
    case SyncDialogType.Successful:
      return 'success';
    case SyncDialogType.Unsuccessful:
      return 'danger';
    case SyncDialogType.InitialisingFailed:
      return 'danger';
    case SyncDialogType.Offline:
      return 'warning';
    default:
      return 'text';
  }
});

const isSyncRequestDialog = computed<boolean>(() => props.dialogType === SyncDialogType.Requested);

const isSyncProcessingDialog = computed<boolean>(
  () =>
    props.dialogType === SyncDialogType.Processing ||
    props.dialogType === SyncDialogType.Initialising
);

const isSyncSuccessfulDialog = computed<boolean>(
  () => props.dialogType === SyncDialogType.Successful
);

const isSyncUnsuccessfulDialog = computed<boolean>(
  () => props.dialogType === SyncDialogType.Unsuccessful
);

const isSyncFailedDialog = computed<boolean>(
  () => props.dialogType === SyncDialogType.InitialisingFailed
);

const startDisabled = computed<boolean>(
  () =>
    appStore.hasBlockingTasks ||
    props.status?.syncProgressStatus === MXSyncProgressStatus.Synchronizing
);

function start() {
  const email = userDetails.value?.email;
  if (!email) return;

  productsStore.syncProduct({
    productId: productsStore.activeProductId,
    userId: email,
    editorType: editorStore.editorType
  });

  // Emit progress update to the toastService
  const toastId = Symbol('sync-toast');  // Create a unique ID for the toast
  const totalModels = props.status?.allModels.length || 0;  // Get total number of models
  toastService.displaySpinner(toastId, 'Synchronization requested', 0, totalModels);  // Initialize the spinner toast

  const interval = setInterval(() => {  // Set up interval to update progress
    const progress = props.status?.syncedModels.length || 0;  // Get current progress
    toastService.displaySpinner(toastId, 'Synchronization requested', progress, totalModels);  // Update spinner toast
    
    if (progress >= totalModels) {  // Check if synchronization is complete
      clearInterval(interval);  // Clear interval
      toastService.dismiss(toastId);  // Dismiss the toast
    }
  }, 1000);  // Interval time set to 1 second
}

watch(
  () => connectionsStore.isOffline,
  nowOffline => {
    if (nowOffline)
      eventService.emit(EventType.OpenDialog, {
        dialogName: DialogNames.Sync,
        options: {
          props: {
            dialogType: SyncDialogType.Offline
          },
          modal: true
        }
      });
  }
);
</script>

<style scoped>
.sync-progress {
  color: var(--font-disabled-color);
  fill: var(--font-disabled-color);

  li {
    display: flex;
    align-items: center;

    .icon {
      margin-right: var(--base-spacing-1);
    }
  }

  .syncing {
    color: var(--font-color);
    fill: var(--font-color);
  }

  .synced {
    color: var(--success);
    fill: var(--success);
  }
}

.unsuccessful {
  display: flex;
  flex-direction: column;
  align-items: center;

  .unsuccessful-message {
    display: flex;

    a {
      color: var(--link-color);
    }

    p {
      padding-right: var(--base-spacing-1);
    }
  }

  .failed-model {
    display: flex;
    align-items: center;
    color: var(--danger);
    fill: var(--danger);

    p {
      padding-left: var(--base-spacing-1);
    }
  }
}

.successful {
  display: flex;
  flex-direction: column;
  align-items: center;

  ul {
    list-style: none;
    padding: 0;
    margin: 0;

    li {
      display: flex;
      align-items: center;
      margin-bottom: var(--base-spacing-1);

      .icon {
        margin-right: var(--base-spacing-1);
      }
    }
  }
}
</style>
```

With these highlighted changes, you should be able to integrate the synchronization progress into the toaster component



